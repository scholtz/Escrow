#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 4 8
    bytecblock "d" 0x151f7c75 "e"
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    txn NumAppArgs
    bz main_bare_routing@14
    pushbytess 0x26bf1370 0x362d47d7 0xd9b663f3 0x64ccd930 0x11f927d0 0xa8c7fb20 0x8ab1c160 0x64d2d782 0xc81e228d // method "create(txn,uint64,byte[32])void", method "makeHash(byte[])byte[]", method "getEscrow(byte[32])(uint64,uint64,uint64,uint64,address,byte[32])", method "latestTimestamp()uint64", method "withdraw(byte[32],byte[])void", method "cancel(byte[32])void", method "optInToASA(pay,uint64)void", method "adminWithdrawable(uint64)uint64", method "adminWithdraw(uint64)uint64"
    txna ApplicationArgs 0
    match main_create_route@3 main_makeHash_route@4 main_getEscrow_route@5 main_latestTimestamp_route@6 main_withdraw_route@7 main_cancel_route@8 main_optInToASA_route@9 main_adminWithdrawable_route@10 main_adminWithdraw_route@11

main_after_if_else@18:
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    intc_1 // 0
    return

main_adminWithdraw_route@11:
    // smart_contracts/escrow/contract.algo.ts:204
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/escrow/contract.algo.ts:204
    // @arc4.abimethod({ readonly: true })
    callsub adminWithdraw
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_adminWithdrawable_route@10:
    // smart_contracts/escrow/contract.algo.ts:184
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/escrow/contract.algo.ts:184
    // @arc4.abimethod({ readonly: true })
    callsub adminWithdrawable
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_optInToASA_route@9:
    // smart_contracts/escrow/contract.algo.ts:160
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/escrow/contract.algo.ts:160
    // @arc4.abimethod()
    callsub optInToASA
    intc_0 // 1
    return

main_cancel_route@8:
    // smart_contracts/escrow/contract.algo.ts:142
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/escrow/contract.algo.ts:142
    // @arc4.abimethod()
    callsub cancel
    intc_0 // 1
    return

main_withdraw_route@7:
    // smart_contracts/escrow/contract.algo.ts:121
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/escrow/contract.algo.ts:121
    // @arc4.abimethod()
    callsub withdraw
    intc_0 // 1
    return

main_latestTimestamp_route@6:
    // smart_contracts/escrow/contract.algo.ts:110
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub latestTimestamp
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_getEscrow_route@5:
    // smart_contracts/escrow/contract.algo.ts:100
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/escrow/contract.algo.ts:100
    // @arc4.abimethod({ readonly: true })
    callsub getEscrow
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_makeHash_route@4:
    // smart_contracts/escrow/contract.algo.ts:89
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/escrow/contract.algo.ts:89
    // @arc4.abimethod({ readonly: true })
    callsub makeHash
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_create_route@3:
    // smart_contracts/escrow/contract.algo.ts:44
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    txn GroupIndex
    intc_0 // 1
    -
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    // smart_contracts/escrow/contract.algo.ts:44
    // @arc4.abimethod()
    callsub create
    intc_0 // 1
    return

main_bare_routing@14:
    // smart_contracts/escrow/contract.algo.ts:27
    // export class Escrow extends Contract {
    txn OnCompletion
    bnz main_after_if_else@18
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts/escrow/contract.algo.ts::Escrow.create(txnDeposit: uint64, rescueDelay: uint64, secretHash: bytes) -> void:
create:
    // smart_contracts/escrow/contract.algo.ts:44-45
    // @arc4.abimethod()
    // public create(txnDeposit: gtxn.Transaction, rescueDelay: uint64, secretHash: arc4.StaticBytes<32>): void {
    proto 3 0
    intc_1 // 0
    dup
    pushbytes ""
    // smart_contracts/escrow/contract.algo.ts:46
    // let tokenId: uint64 = 0
    intc_1 // 0
    // smart_contracts/escrow/contract.algo.ts:47-48
    // let amount: uint64 = 0
    // let depositIsValid: boolean = false
    dupn 2
    // smart_contracts/escrow/contract.algo.ts:31
    // public escrows = BoxMap<arc4.StaticBytes<32>, EscrowInstance>({ keyPrefix: 'e' })
    bytec_2 // "e"
    frame_dig -1
    concat
    dup
    // smart_contracts/escrow/contract.algo.ts:49
    // assert(this.escrows(secretHash).exists === false, 'Escrow with the same id already exists')
    box_len
    bury 1
    !
    assert // Escrow with the same id already exists
    // smart_contracts/escrow/contract.algo.ts:50
    // if (txnDeposit.type === TransactionType.Payment) {
    frame_dig -3
    gtxns TypeEnum
    dup
    intc_0 // 1
    ==
    bz create_after_if_else@2
    // smart_contracts/escrow/contract.algo.ts:51
    // assert(txnDeposit.receiver === Global.currentApplicationAddress, 'Receiver must be the escrow app')
    frame_dig -3
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Receiver must be the escrow app
    // smart_contracts/escrow/contract.algo.ts:52
    // assert(txnDeposit.sender === Txn.sender, 'Sender of deposit must be the same as the sender of the app call')
    frame_dig -3
    gtxns Sender
    txn Sender
    ==
    assert // Sender of deposit must be the same as the sender of the app call
    // smart_contracts/escrow/contract.algo.ts:53
    // amount = txnDeposit.amount
    frame_dig -3
    gtxns Amount
    frame_bury 4
    // smart_contracts/escrow/contract.algo.ts:54
    // depositIsValid = true
    intc_0 // 1
    frame_bury 5

create_after_if_else@2:
    // smart_contracts/escrow/contract.algo.ts:56
    // if (txnDeposit.type === TransactionType.AssetTransfer) {
    frame_dig 7
    intc_2 // 4
    ==
    bz create_after_if_else@4
    // smart_contracts/escrow/contract.algo.ts:57
    // assert(txnDeposit.assetReceiver === Global.currentApplicationAddress, 'Receiver must be the escrow app')
    frame_dig -3
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Receiver must be the escrow app
    // smart_contracts/escrow/contract.algo.ts:58
    // amount = txnDeposit.assetAmount
    frame_dig -3
    gtxns AssetAmount
    frame_bury 4
    // smart_contracts/escrow/contract.algo.ts:59
    // tokenId = txnDeposit.xferAsset.id
    frame_dig -3
    gtxns XferAsset
    frame_bury 3
    // smart_contracts/escrow/contract.algo.ts:60
    // depositIsValid = true
    intc_0 // 1
    frame_bury 5

create_after_if_else@4:
    // smart_contracts/escrow/contract.algo.ts:62
    // assert(amount > 0, 'Deposit should be positive number')
    frame_dig 4
    assert // Deposit should be positive number
    // smart_contracts/escrow/contract.algo.ts:63
    // assert(depositIsValid, 'Deposit must be asset transfer or payment')
    frame_dig 5
    assert // Deposit must be asset transfer or payment
    // smart_contracts/escrow/contract.algo.ts:65
    // const tokenIdN = new UintN64(tokenId)
    frame_dig 3
    itob
    dup
    frame_bury 1
    // smart_contracts/escrow/contract.algo.ts:66
    // let prevDeposits: uint64 = 0
    intc_1 // 0
    frame_bury 2
    // smart_contracts/escrow/contract.algo.ts:35
    // public allDeposits = BoxMap<UintN64, UintN64>({ keyPrefix: 'd' })
    bytec_0 // "d"
    swap
    concat
    dup
    frame_bury 0
    // smart_contracts/escrow/contract.algo.ts:67
    // if (this.allDeposits(tokenIdN).exists) {
    box_len
    bury 1
    bz create_after_if_else@6
    // smart_contracts/escrow/contract.algo.ts:68
    // prevDeposits = this.allDeposits(tokenIdN).value.native
    frame_dig 0
    box_get
    assert // Box must have value
    btoi
    frame_bury 2

create_after_if_else@6:
    // smart_contracts/escrow/contract.algo.ts:70
    // this.allDeposits(tokenIdN).value = new UintN64(prevDeposits + amount)
    frame_dig 2
    frame_dig 4
    dup
    cover 2
    +
    itob
    frame_dig 0
    swap
    box_put
    // smart_contracts/escrow/contract.algo.ts:73
    // account: new Address(Txn.sender),
    txn Sender
    // smart_contracts/escrow/contract.algo.ts:74
    // createdTime: new UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/escrow/contract.algo.ts:75
    // rescueTime: new UintN64(Global.latestTimestamp + rescueDelay),
    global LatestTimestamp
    frame_dig -2
    +
    itob
    // smart_contracts/escrow/contract.algo.ts:78
    // amount: new UintN64(amount),
    uncover 3
    itob
    // smart_contracts/escrow/contract.algo.ts:72-79
    // const escrow = new EscrowInstance({
    //   account: new Address(Txn.sender),
    //   createdTime: new UintN64(Global.latestTimestamp),
    //   rescueTime: new UintN64(Global.latestTimestamp + rescueDelay),
    //   tokenId: new UintN64(tokenId),
    //   secretHash: secretHash,
    //   amount: new UintN64(amount),
    // })
    cover 2
    concat
    frame_dig 1
    concat
    swap
    concat
    swap
    concat
    frame_dig -1
    concat
    // smart_contracts/escrow/contract.algo.ts:81
    // this.escrows(secretHash).value = escrow.copy()
    frame_dig 6
    swap
    box_put
    retsub


// smart_contracts/escrow/contract.algo.ts::Escrow.makeHash(secret: bytes) -> bytes:
makeHash:
    // smart_contracts/escrow/contract.algo.ts:89-90
    // @arc4.abimethod({ readonly: true })
    // public makeHash(secret: arc4.DynamicBytes): bytes {
    proto 1 1
    // smart_contracts/escrow/contract.algo.ts:91
    // return op.keccak256(secret.bytes)
    frame_dig -1
    keccak256
    retsub


// smart_contracts/escrow/contract.algo.ts::Escrow.getEscrow(secretHash: bytes) -> bytes:
getEscrow:
    // smart_contracts/escrow/contract.algo.ts:100-101
    // @arc4.abimethod({ readonly: true })
    // public getEscrow(secretHash: arc4.StaticBytes<32>): EscrowInstance {
    proto 1 1
    // smart_contracts/escrow/contract.algo.ts:31
    // public escrows = BoxMap<arc4.StaticBytes<32>, EscrowInstance>({ keyPrefix: 'e' })
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/escrow/contract.algo.ts:102
    // return this.escrows(secretHash).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/escrow/contract.algo.ts::Escrow.latestTimestamp() -> uint64:
latestTimestamp:
    // smart_contracts/escrow/contract.algo.ts:112
    // return Global.latestTimestamp
    global LatestTimestamp
    retsub


// smart_contracts/escrow/contract.algo.ts::Escrow.withdraw(secretHash: bytes, secret: bytes) -> void:
withdraw:
    // smart_contracts/escrow/contract.algo.ts:121-122
    // @arc4.abimethod()
    // public withdraw(secretHash: arc4.StaticBytes<32>, secret: arc4.DynamicBytes) {
    proto 2 0
    // smart_contracts/escrow/contract.algo.ts:31
    // public escrows = BoxMap<arc4.StaticBytes<32>, EscrowInstance>({ keyPrefix: 'e' })
    bytec_2 // "e"
    frame_dig -2
    concat
    // smart_contracts/escrow/contract.algo.ts:123
    // assert(this.escrows(secretHash).exists, 'The escrow does not exists')
    dup
    box_len
    bury 1
    assert // The escrow does not exists
    // smart_contracts/escrow/contract.algo.ts:124
    // assert(op.keccak256(secret.bytes) === secretHash.bytes, 'The password is not correct')
    frame_dig -1
    keccak256
    frame_dig -2
    ==
    assert // The password is not correct
    // smart_contracts/escrow/contract.algo.ts:126
    // const escrow = this.escrows(secretHash).value.copy()
    dup
    box_get
    assert // Box must have value
    // smart_contracts/escrow/contract.algo.ts:128
    // Global.latestTimestamp < escrow.rescueTime.native,
    global LatestTimestamp
    dig 1
    intc_3 // 8
    extract_uint64
    <
    // smart_contracts/escrow/contract.algo.ts:127-130
    // assert(
    //   Global.latestTimestamp < escrow.rescueTime.native,
    //   'Escrow can be redeemed with password up to the rescue time',
    // )
    assert // Escrow can be redeemed with password up to the rescue time
    // smart_contracts/escrow/contract.algo.ts:132
    // this._send(new Address(Txn.sender), escrow.tokenId.native, escrow.amount.native)
    txn Sender
    dig 1
    pushint 16 // 16
    extract_uint64
    uncover 2
    pushint 24 // 24
    extract_uint64
    callsub _send
    // smart_contracts/escrow/contract.algo.ts:135
    // this.escrows(secretHash).delete()
    box_del
    pop
    retsub


// smart_contracts/escrow/contract.algo.ts::Escrow.cancel(secretHash: bytes) -> void:
cancel:
    // smart_contracts/escrow/contract.algo.ts:142-143
    // @arc4.abimethod()
    // public cancel(secretHash: arc4.StaticBytes<32>) {
    proto 1 0
    // smart_contracts/escrow/contract.algo.ts:31
    // public escrows = BoxMap<arc4.StaticBytes<32>, EscrowInstance>({ keyPrefix: 'e' })
    bytec_2 // "e"
    frame_dig -1
    concat
    // smart_contracts/escrow/contract.algo.ts:144
    // assert(this.escrows(secretHash).exists, 'The escrow does not exists')
    dup
    box_len
    bury 1
    assert // The escrow does not exists
    // smart_contracts/escrow/contract.algo.ts:145
    // const escrow = this.escrows(secretHash).value.copy()
    dup
    box_get
    assert // Box must have value
    // smart_contracts/escrow/contract.algo.ts:146
    // assert(escrow.rescueTime.native < Global.latestTimestamp, 'The escrow cannot be canceled yet')
    dup
    intc_3 // 8
    extract_uint64
    global LatestTimestamp
    <
    assert // The escrow cannot be canceled yet
    // smart_contracts/escrow/contract.algo.ts:148
    // this._send(escrow.account, escrow.tokenId.native, escrow.amount.native)
    dup
    extract 32 32 // on error: Index access is out of bounds
    dig 1
    pushint 16 // 16
    extract_uint64
    uncover 2
    pushint 24 // 24
    extract_uint64
    callsub _send
    // smart_contracts/escrow/contract.algo.ts:151
    // this.escrows(secretHash).delete()
    box_del
    pop
    retsub


// smart_contracts/escrow/contract.algo.ts::Escrow.optInToASA(txnDeposit: uint64, assetId: bytes) -> void:
optInToASA:
    // smart_contracts/escrow/contract.algo.ts:160-161
    // @arc4.abimethod()
    // public optInToASA(txnDeposit: gtxn.PaymentTxn, assetId: UintN64) {
    proto 2 0
    // smart_contracts/escrow/contract.algo.ts:163
    // txnDeposit.receiver === Global.currentApplicationAddress,
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/escrow/contract.algo.ts:162-165
    // assert(
    //   txnDeposit.receiver === Global.currentApplicationAddress,
    //   'Receiver of the optin fee must be the current smart contract',
    // )
    assert // Receiver of the optin fee must be the current smart contract
    // smart_contracts/escrow/contract.algo.ts:166
    // assert(txnDeposit.amount === 100_000, 'Opt in fee to cover MBR')
    frame_dig -2
    gtxns Amount
    pushint 100000 // 100000
    ==
    assert // Opt in fee to cover MBR
    // smart_contracts/escrow/contract.algo.ts:167
    // assert(Global.currentApplicationAddress.isOptedIn(Asset(assetId.native)) === false, 'Asset is already opted in')
    global CurrentApplicationAddress
    frame_dig -1
    btoi
    swap
    dig 1
    asset_holding_get AssetBalance
    bury 1
    !
    assert // Asset is already opted in
    // smart_contracts/escrow/contract.algo.ts:168-175
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId.native,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/escrow/contract.algo.ts:172
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // smart_contracts/escrow/contract.algo.ts:171
    // assetAmount: 0,
    intc_1 // 0
    itxn_field AssetAmount
    itxn_field XferAsset
    // smart_contracts/escrow/contract.algo.ts:168-174
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId.native,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/escrow/contract.algo.ts:173
    // fee: 0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/escrow/contract.algo.ts:168-175
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId.native,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/escrow/contract.algo.ts::Escrow.adminWithdrawable(assetId: uint64) -> uint64:
adminWithdrawable:
    // smart_contracts/escrow/contract.algo.ts:184-185
    // @arc4.abimethod({ readonly: true })
    // public adminWithdrawable(assetId: uint64): uint64 {
    proto 1 1
    // smart_contracts/escrow/contract.algo.ts:186
    // const assetIdN = new UintN64(assetId)
    frame_dig -1
    itob
    // smart_contracts/escrow/contract.algo.ts:187
    // if (assetId === 0) {
    frame_dig -1
    bnz adminWithdrawable_else_body@2
    // smart_contracts/escrow/contract.algo.ts:189
    // Global.currentApplicationAddress.balance -
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/escrow/contract.algo.ts:190
    // Global.currentApplicationAddress.minBalance -
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/escrow/contract.algo.ts:189-190
    // Global.currentApplicationAddress.balance -
    // Global.currentApplicationAddress.minBalance -
    -
    // smart_contracts/escrow/contract.algo.ts:35
    // public allDeposits = BoxMap<UintN64, UintN64>({ keyPrefix: 'd' })
    bytec_0 // "d"
    uncover 2
    concat
    // smart_contracts/escrow/contract.algo.ts:191
    // this.allDeposits(assetIdN).value.native
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/escrow/contract.algo.ts:189-191
    // Global.currentApplicationAddress.balance -
    // Global.currentApplicationAddress.minBalance -
    // this.allDeposits(assetIdN).value.native
    -
    // smart_contracts/escrow/contract.algo.ts:188-192
    // return (
    //   Global.currentApplicationAddress.balance -
    //   Global.currentApplicationAddress.minBalance -
    //   this.allDeposits(assetIdN).value.native
    // )
    retsub

adminWithdrawable_else_body@2:
    // smart_contracts/escrow/contract.algo.ts:194
    // return Asset(assetId).balance(Global.currentApplicationAddress) - this.allDeposits(assetIdN).value.native
    global CurrentApplicationAddress
    frame_dig -1
    asset_holding_get AssetBalance
    assert // account opted into asset
    // smart_contracts/escrow/contract.algo.ts:35
    // public allDeposits = BoxMap<UintN64, UintN64>({ keyPrefix: 'd' })
    bytec_0 // "d"
    uncover 2
    concat
    // smart_contracts/escrow/contract.algo.ts:194
    // return Asset(assetId).balance(Global.currentApplicationAddress) - this.allDeposits(assetIdN).value.native
    box_get
    assert // Box must have value
    btoi
    -
    retsub


// smart_contracts/escrow/contract.algo.ts::Escrow.adminWithdraw(assetId: uint64) -> uint64:
adminWithdraw:
    // smart_contracts/escrow/contract.algo.ts:204-205
    // @arc4.abimethod({ readonly: true })
    // public adminWithdraw(assetId: uint64): uint64 {
    proto 1 1
    // smart_contracts/escrow/contract.algo.ts:206
    // const assetIdN = new UintN64(assetId)
    frame_dig -1
    itob
    // smart_contracts/escrow/contract.algo.ts:207
    // if (assetId === 0) {
    frame_dig -1
    bnz adminWithdraw_else_body@2
    // smart_contracts/escrow/contract.algo.ts:209
    // Global.currentApplicationAddress.balance -
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/escrow/contract.algo.ts:210
    // Global.currentApplicationAddress.minBalance -
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/escrow/contract.algo.ts:209-210
    // Global.currentApplicationAddress.balance -
    // Global.currentApplicationAddress.minBalance -
    -
    // smart_contracts/escrow/contract.algo.ts:35
    // public allDeposits = BoxMap<UintN64, UintN64>({ keyPrefix: 'd' })
    bytec_0 // "d"
    uncover 2
    concat
    // smart_contracts/escrow/contract.algo.ts:211
    // this.allDeposits(assetIdN).value.native
    box_get
    assert // Box must have value
    btoi
    // smart_contracts/escrow/contract.algo.ts:209-211
    // Global.currentApplicationAddress.balance -
    // Global.currentApplicationAddress.minBalance -
    // this.allDeposits(assetIdN).value.native
    -
    // smart_contracts/escrow/contract.algo.ts:208-212
    // return (
    //   Global.currentApplicationAddress.balance -
    //   Global.currentApplicationAddress.minBalance -
    //   this.allDeposits(assetIdN).value.native
    // )
    retsub

adminWithdraw_else_body@2:
    // smart_contracts/escrow/contract.algo.ts:214
    // return Asset(assetId).balance(Global.currentApplicationAddress) - this.allDeposits(assetIdN).value.native
    global CurrentApplicationAddress
    frame_dig -1
    asset_holding_get AssetBalance
    assert // account opted into asset
    // smart_contracts/escrow/contract.algo.ts:35
    // public allDeposits = BoxMap<UintN64, UintN64>({ keyPrefix: 'd' })
    bytec_0 // "d"
    uncover 2
    concat
    // smart_contracts/escrow/contract.algo.ts:214
    // return Asset(assetId).balance(Global.currentApplicationAddress) - this.allDeposits(assetIdN).value.native
    box_get
    assert // Box must have value
    btoi
    -
    retsub


// smart_contracts/escrow/contract.algo.ts::Escrow._send(receiver: bytes, assetId: uint64, amount: uint64) -> void:
_send:
    // smart_contracts/escrow/contract.algo.ts:221
    // private _send(receiver: Address, assetId: uint64, amount: uint64): void {
    proto 3 0
    // smart_contracts/escrow/contract.algo.ts:222
    // let prevDeposits: uint64 = 0
    intc_1 // 0
    // smart_contracts/escrow/contract.algo.ts:223
    // const tokenIdN = new UintN64(assetId)
    frame_dig -2
    itob
    // smart_contracts/escrow/contract.algo.ts:35
    // public allDeposits = BoxMap<UintN64, UintN64>({ keyPrefix: 'd' })
    bytec_0 // "d"
    swap
    concat
    dup
    // smart_contracts/escrow/contract.algo.ts:225
    // if (this.allDeposits(tokenIdN).exists) {
    box_len
    bury 1
    bz _send_after_if_else@2
    // smart_contracts/escrow/contract.algo.ts:226
    // prevDeposits = this.allDeposits(tokenIdN).value.native
    frame_dig 1
    box_get
    assert // Box must have value
    btoi
    frame_bury 0

_send_after_if_else@2:
    // smart_contracts/escrow/contract.algo.ts:228
    // this.allDeposits(tokenIdN).value = new UintN64(prevDeposits - amount)
    frame_dig 0
    frame_dig -1
    -
    itob
    frame_dig 1
    swap
    box_put
    // smart_contracts/escrow/contract.algo.ts:230
    // if (assetId === 0) {
    frame_dig -2
    bnz _send_else_body@5
    // smart_contracts/escrow/contract.algo.ts:231-237
    // itxn
    //   .payment({
    //     amount: amount,
    //     fee: 0,
    //     receiver: receiver.bytes,
    //   })
    //   .submit()
    itxn_begin
    frame_dig -3
    itxn_field Receiver
    frame_dig -1
    itxn_field Amount
    // smart_contracts/escrow/contract.algo.ts:231-236
    // itxn
    //   .payment({
    //     amount: amount,
    //     fee: 0,
    //     receiver: receiver.bytes,
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/escrow/contract.algo.ts:234
    // fee: 0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/escrow/contract.algo.ts:231-237
    // itxn
    //   .payment({
    //     amount: amount,
    //     fee: 0,
    //     receiver: receiver.bytes,
    //   })
    //   .submit()
    itxn_submit
    retsub

_send_else_body@5:
    // smart_contracts/escrow/contract.algo.ts:239-246
    // itxn
    //   .assetTransfer({
    //     assetAmount: amount,
    //     fee: 0,
    //     assetReceiver: receiver.bytes,
    //     xferAsset: assetId,
    //   })
    //   .submit()
    itxn_begin
    frame_dig -2
    itxn_field XferAsset
    frame_dig -3
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field AssetAmount
    // smart_contracts/escrow/contract.algo.ts:239-245
    // itxn
    //   .assetTransfer({
    //     assetAmount: amount,
    //     fee: 0,
    //     assetReceiver: receiver.bytes,
    //     xferAsset: assetId,
    //   })
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/escrow/contract.algo.ts:242
    // fee: 0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/escrow/contract.algo.ts:239-246
    // itxn
    //   .assetTransfer({
    //     assetAmount: amount,
    //     fee: 0,
    //     assetReceiver: receiver.bytes,
    //     xferAsset: assetId,
    //   })
    //   .submit()
    itxn_submit
    retsub
